# Code Timeout - Surgical Checklist for Development

**Source:** Hacker News (d100=14) | All-time (d6=6)  
**Finding:** ["How I use Claude Code: Separation of planning and execution"](https://boristane.com/blog/how-i-use-claude-code/)  
**Lens:** Cross-Domain Steal (d10=10)  
**Modifier:** Perspective Shift (d6=5)  
**Format:** Quick Take (d6=3)

**Domain:** Surgery → Code Development

---

## The Finding

Boris Tane's Claude Code workflow: Research → Plan → Annotate (1-6 cycles) → Todo List → Implementation. Core principle: "never let Claude write code until you've reviewed and approved a written plan."

Key insight: The most expensive failure mode in AI-assisted coding isn't syntax errors or bad logic. It's implementations that work in isolation but break the surrounding system. A function that ignores an existing caching layer. A migration that doesn't account for the ORM's conventions. An API endpoint that duplicates logic that already exists elsewhere.

The research phase prevents all of this. The plan document becomes a review surface that catches problems before any code is written.

---

## Cross-Domain Steal: Surgical Checklists

The WHO Surgical Safety Checklist reduced surgical mortality by 47%. Not by teaching surgeons better cutting techniques. By forcing a timeout before the first incision:

1. **Sign In** (before anesthesia) — verify patient identity, procedure, consent
2. **Time Out** (before incision) — entire team confirms the plan aloud
3. **Sign Out** (before leaving OR) — verify counts, specimens, next steps

The checklist doesn't make surgeons smarter. It makes them **stop and verify the plan** before irreversible action.

Boris's workflow is the same structure:

1. **Research** = Sign In (understand the patient/codebase)
2. **Plan + Annotation Cycles** = Time Out (entire "team" - you and Claude - confirms the plan)
3. **Implementation** = Surgery (execute with confidence because the plan is verified)

---

## Brainstorming (Cross-Domain Steal + Perspective Shift)

### 1. The Surgical Checklist Parallel (direct analogy)
- WHO checklist reduced mortality by 47% not by teaching surgery, but by forcing a timeout
- Boris's workflow is a code timeout: research → plan → annotate → verify → THEN execute
- The "don't implement yet" guard is the Time Out call
- **Score:** Novelty 8, Viability 9, Impact 8, Fun 7, Diversity 8 = **40**

### 2. Code's Perspective: "Stop Writing Me Until You Know What I Am"
- Bad code is premature code - written before the requirements crystallized
- From code's POV: every refactor is a time traveler trying to warn their past self
- The plan.md is the time machine that lets you fix the problem before it exists
- Code doesn't want to be written wrong and then rewritten right. It wants to be written right once.
- **Score:** Novelty 9, Viability 7, Impact 8, Fun 9, Diversity 9 = **42**

### 3. The "No Code Before Noon" Rule (constraint-based)
- What if you literally couldn't write code for the first X hours of a project day?
- Research-only morning, implementation-only afternoon
- Forces the separation Boris describes
- **Score:** Novelty 7, Viability 6, Impact 6, Fun 8, Diversity 7 = **34**

### 4. Eliminate The Undo Button (adversarial twist)
- What if you couldn't refactor? Every line is permanent from first write
- Boris's workflow is essentially "code without an undo button" - you HAVE to get the plan right
- The pressure to plan correctly would be immense
- **Score:** Novelty 8, Viability 5, Impact 7, Fun 8, Diversity 7 = **35**

### 5. The Code Review That Happens Before Code Exists
- Traditional code review: after the fact (reviewing what was written)
- Boris's annotation cycle: reviewing the INTENT before execution
- Plan.md is a pre-code code review - catching architectural mistakes before they're written
- Much cheaper to change a plan document than to change working code
- **Score:** Novelty 8, Viability 9, Impact 9, Fun 7, Diversity 8 = **41**

---

## Selected Approach: #2 — Code's Perspective (Score: 42)

**Thesis:** Bad code isn't wrong code. It's premature code - written before the plan was right. From the code's point of view, every refactor is a failed time travel attempt.

**Why This Wins:**
- **Novelty 9** — Personifying code's desire to not exist in wrong forms is fresh
- **Viability 7** — Not a tool/process, but a mindset shift (slightly abstract)
- **Impact 8** — Reframes refactoring as a planning failure, not an execution failure
- **Fun 9** — "Code as time traveler trying to warn its past self" is evocative
- **Diversity 9** — Perspective shift brings a completely different angle to the "plan before you code" advice

**Hook:** What if your code could send a message to the moment before it was written? Every refactor is exactly that - a desperate attempt to undo the damage of coding too soon.

---

## Article Structure (Quick Take - 250-400 words)

**Format:** One sharp point, tight focus, no tutorial elements

1. **Hook** — Code's perspective: "I didn't want to exist this way"
2. **The Problem** — Refactoring isn't fixing bad code, it's fixing premature code
3. **The Insight** — Plan.md is a time machine: fix the problem before code exists
4. **The Payoff** — Surgical timeout for code: verify the plan before the first line

**Tone:** Sharp, slightly philosophical, grounded in the surgical checklist parallel but focused on the code's POV.
